

[来源CodeTop](https://codeTop.cc)

# 按照热度顺序
## 字节的to题目

## 1-10
### 3.无重复字符的最长子串
    滑动窗口，临时变量，hash表记录最近一次出现的下标

    临时变量记录已经遍历过的最长的不重复子串

    遍历数组：一旦发现有重复的，就重置滑动窗口的起始位置到当前位置
    
### 146、LRU缓存机制
    1、hashmap + Deque
        使用deque来保存最近使用的元素，每次读写、，都调整deque的元素
            peekFirst、pollFirst

    2、LinkedHashMap  + 自定义removeEldestEntry
### 25、K个一组反转链表
    k个一组，反转多次
    最后判断反转的节点个数若不等于k，则在翻转一次，转回来

### 206.反转链表
### 215、数组中的第K个最大元素
    手写快排？三路快跑？

### 15、三数之和
### 103、二叉树的锯齿形层次遍历
### 200、岛屿数量
### 121、买卖股票的最佳时机
### 33、搜索旋转排序数组

## 11-20
### 1、两数之和
### 236、二叉树的最近公共祖先
### 42、接雨水
### 54、螺旋矩阵
### 5、最长回文子串

### 160、相交链表
### 53、最大子数组和
    简单do
### 46、全排列
    用递归
### 31、下一个排列
### 23、合并K个排序链表


---------------

## 21-30
### 300. 最长上升子序列
    用一个数组dp，dp[len] 表示最长上升子序列最长的时候，对应的最后一个数字是多少，遇到比当前元素大的，直接设值，len+1，否则，二分查找，找第一个大于当前元素的dp位置，更新进去
### 199. 二叉树的右视图
    使用两个队列，使用add、poll操作
### 143. 重排链表
    方法1：遍历，使用list保存节点内容，再遍历，改变节点指向
    方法2：先求中点、在反转右边的链表、最后合并左半边和右半边的链表，记得最后避免出现环
### 20. 有效的括号
    使用栈，进行匹配消消乐
### 102. 二叉树的层序遍历
    一个队列 + 一个遍历报错当前层次的元素个数
### 88. 合并两个有序数组
    从尾部开始合并
### 21. 合并两个有序链表
    简单题目
### 92. 反转链表 II
    遍历加反转
### 141. 环形链表
    快慢指针，判断是否有环
### 415. 字符串相加
    模拟即可，记得处理最后的进位



## 31-40
### 124. 二叉树中的最大路径和
    递归，针对当前节点，考虑一下三种情况
    仅考虑本节点的值
    考虑左右子节点中其中给一个节点的和本节点值的和
    考虑左右子节点和本节点值的和，取最大值，作为本节点的结果
    最后去全局的最大和
### 41. 缺失的第一个正数     (困难)放弃
### 72. 编辑距离            (困难)放弃
### 56. 合并区间
    对每个区间，按照开始字段start进行排序，然后依次判断是否可以合并
    需要自定义排序方法
### 221. 最大正方形
    猜测，使用dp[i][j]，表示以i,j 为右下角时候的正方形中，最大的正方形边长  
        转移方程为：dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1
        还需要考虑边界情况

### 148. 排序链表
    合并排序
    1、快慢指针，分成两段
    2、对左右两段，进行合并排序
    记得断开两段之间的链接，避免出现环
### 69. x 的平方根 
    二分查找
        mid * mid 后和x比较
    注意需要先转换为long，再比较，避免int相乘后溢出未负数
### 165. 比较版本号
    逗号分割，转换为数字，进行比较
    双指针，遇到.的时候，暂停，进行比较
### 129. 求根到叶子节点数字之和
    深度优先搜索，需要将根节点的临时结果带到下一层的子节点中
    需要注意，递归结束返回后，需要将结果*10，再进行后续处理

### 105. 从前序与中序遍历序列构造二叉树
    先在根据前序的结果，求在中序中的中间位置，分成左右两部分
    然后再依次构建二叉树





















