

[来源CodeTop](https://codeTop.cc)

# 按照热度顺序
## 字节的to题目

## 1-10
### 3.无重复字符的最长子串
    滑动窗口，临时变量，hash表记录最近一次出现的下标

    临时变量记录已经遍历过的最长的不重复子串

    遍历数组：一旦发现有重复的，就重置滑动窗口的起始位置到当前位置
    
### 146、LRU缓存机制
    1、hashmap + Deque
        使用deque来保存最近使用的元素，每次读写、，都调整deque的元素
            peekFirst、pollFirst

    2、LinkedHashMap  + 自定义removeEldestEntry
### 25、K个一组反转链表
    k个一组，反转多次
    最后判断反转的节点个数若不等于k，则在翻转一次，转回来

### 206.反转链表
### 215、数组中的第K个最大元素
    手写快排？三路快排？

### 15、三数之和
    先排序，然后再从左到右遍历，每个小于0的数字target，在右边找到两个相加和等于-target的和，此刻的三个数字，即为一个结果
### 103、二叉树的锯齿形层次遍历
    用两个栈、两个队列，都行

### 200、岛屿数量
    用一个二维数组，保存是否已经被访问过
    用一个dfs，表示当前坐标是否是未被访问过的陆地，向上下左右深度搜索
### 121、买卖股票的最佳时机
    找到当前的最小值，遍历过程中更新，然后求利润，并求利润最大值

### 33、搜索旋转排序数组
    二分查找 l、r，针对target 和 mid值，进行区分
    相等，则找到，返回
    不相等，则具体判断target和mid值、左边界、右边界的大小，调整l、r
    最后，需要对l、r相等的情况判断

## 11-20
### 1、两数之和
### 236、二叉树的最近公共祖先
### 42、接雨水
### 54、螺旋矩阵
### 5、最长回文子串

### 160、相交链表
### 53、最大子数组和
    简单do
### 46、全排列
    用递归
### 31、下一个排列
### 23、合并K个排序链表


---------------

## 21-30
### 300. 最长上升子序列
    用一个数组dp，dp[len] 表示最长上升子序列最长的时候，对应的最后一个数字是多少，遇到比当前元素大的，直接设值，len+1，否则，二分查找，找第一个大于当前元素的dp位置，更新进去
### 199. 二叉树的右视图
    使用两个队列，使用add、poll操作
### 143. 重排链表
    方法1：遍历，使用list保存节点内容，再遍历，改变节点指向
    方法2：先求中点、在反转右边的链表、最后合并左半边和右半边的链表，记得最后避免出现环
### 20. 有效的括号
    使用栈，进行匹配消消乐
### 102. 二叉树的层序遍历
    一个队列 + 一个遍历报错当前层次的元素个数
### 88. 合并两个有序数组
    从尾部开始合并
### 21. 合并两个有序链表
    简单题目
### 92. 反转链表 II
    遍历加反转
### 141. 环形链表
    快慢指针，判断是否有环
### 415. 字符串相加
    模拟即可，记得处理最后的进位



## 31-40
### 124. 二叉树中的最大路径和
    递归，针对当前节点，考虑一下三种情况
    仅考虑本节点的值
    考虑左右子节点中其中给一个节点的和本节点值的和
    考虑左右子节点和本节点值的和，取最大值，作为本节点的结果
    最后去全局的最大和
### 41. 缺失的第一个正数     (困难)放弃
### 72. 编辑距离            (困难)放弃
### 56. 合并区间
    对每个区间，按照开始字段start进行排序，然后依次判断是否可以合并
    需要自定义排序方法
### 221. 最大正方形
    猜测，使用dp[i][j]，表示以i,j 为右下角时候的正方形中，最大的正方形边长  
        转移方程为：dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1
        还需要考虑边界情况

### 148. 排序链表
    合并排序
    1、快慢指针，分成两段
    2、对左右两段，进行合并排序
    记得断开两段之间的链接，避免出现环
### 69. x 的平方根 
    二分查找
        mid * mid 后和x比较
    注意需要先转换为long，再比较，避免int相乘后溢出未负数
### 165. 比较版本号
    逗号分割，转换为数字，进行比较
    双指针，遇到.的时候，暂停，进行比较
### 129. 求根到叶子节点数字之和
    深度优先搜索，需要将根节点的临时结果带到下一层的子节点中
    需要注意，递归结束返回后，需要将结果*10，再进行后续处理

### 105. 从前序与中序遍历序列构造二叉树
    先在根据前序的结果，求在中序中的中间位置，分成左右两部分
    然后再依次构建二叉树



## 41-50
### 101. 对称二叉树
    简单递归即可
    迭代的话,用两个队列，对称入队，依次进行比较
### 补充题4. 手撕快速排序
    leetcode上说，需要针对基本有序的数组进行优化
### 32. 最长有效括号  (困难)
    用栈，栈中保存遍历过程中，未匹配上的）的下标
    
### 22. 括号生成
    用深度优先搜索，特殊情况：只有当剩余（ 的个数 小于 ） 的时候，才可以继续dfs进行匹配
### 93. 复原IP地址
    回溯 + 剪枝

### 4. 寻找两个正序数组的中位数
    若两个数组长度为n、m,则等价于求第(n+m)/2小的数
    使用二分查找的方法，依次在两个数组中移动指针，并比较大小
### 76. 最小覆盖子串  (困难)
    滑动窗口 + hash表

### 39. 组合总和
### 142. 环形链表 II
### 78. 子集

## 51-60
### 322. 零钱兑换
### 1143. 最长公共子序列
### 82. 删除排序链表中的重复元素 II
### 162. 寻找峰值
### 232. 用栈实现队列

### 112. 路径总和
### 94. 二叉树的中序遍历
### 2. 两数相加
### 394. 字符串解码
### 19. 删除链表的倒数第N个节点


















