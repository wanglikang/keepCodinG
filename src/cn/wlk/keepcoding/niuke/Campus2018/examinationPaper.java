package cn.wlk.keepcoding.niuke.Campus2018;

import java.util.Arrays;
import java.util.Scanner;

/**
 * 2019/3/28 13:31
 * author:WLK
 */

/**
 * 题目描述 改试卷
 * <p>
 * <p>
 * 在上小学的时候，我们经常碰到这样的事:考完试后老师懒得改试卷，于是让我们同桌相互交换试卷后为对方批改。但是后来老师发现这样作容易出现作弊，于是他想了一个新办法。 老师将同学分成了 n 个组，其中编号为𝑖的组中有𝑠𝑖个人。然后老师会按某种顺序依次访问 这些组。 对于他访问的第一个组，他会将这组内的所有试卷都收走，放置在桌上;对于他后续访问的每一个组，首先他会从桌上的试卷最上方拿出该组对应人数数量的试卷，随机分配给该组每 个人一张试卷让他们进行批改，而后再将这组学生自己考的试卷收走放置在桌面试卷的最下 方。当他访问完所有的组后他会将桌面上剩余的所有试卷随机分配给他第一个访问的组的学生进行批改。 但他发现这种方法有时候也会出现问题:有可能在中途访问到某个组的时候桌面上的试卷不够分配给这组学生每人一张;也有可能最后会有学生分配到批改自己的试卷，而且这两种情 况是否出现是与他访问每个组的顺序有关的。现在他想知道是否存在一种访问顺序能够使以 上两种情况都不出现，顺利完成试卷批改呢?
 * 输入描述:
 * <p>
 * 第一行包含一个整数𝑛，表示学生组数。2 ≤ 𝑛 ≤ 30
 * 第二行包含𝑛个整数，𝑠1,𝑠2,...,𝑠𝑛，分别表示每组学生的人数。1≤𝑠𝑖 ≤10000
 * <p>
 * 输出描述:
 * <p>
 * 若存在一种访问顺序能使试卷顺利批改完成，输出 Yes，否则输出 No。
 * <p>
 * 示例1
 * 输入
 * 复制
 * <p>
 * 2
 * 10 20
 * <p>
 * 输出
 * 复制
 * <p>
 * No
 * <p>
 * 说明
 * <p>
 * 示例2
 * 输入
 * 复制
 * <p>
 * 4
 * 2 3 3 1
 * <p>
 * 输出
 * 复制
 * <p>
 * Yes
 * <p>
 * 说明
 * <p>
 * 我们可以选择先访问人数为 3 的组，再访问人数为 3 的组，再访问人数
 * 为 1 的组，最后访问人数为 2 的组。
 *
 * 解法：参考论坛上的解法：先选最大的一组，若一圈下来，最大的一组还没发完，则No,否则Yes
 */
public class examinationPaper {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        Arrays.sort(arr);
        int max = arr[n - 1];
        int sum = 0;
        for (int i = 0; i < n - 1; i++) {
            sum += arr[i];
        }
        if (max <= sum)
            System.out.println("YES");
        else System.out.println("NO");
    }
}
